<section id="advanced-discussions-key-management">
 <title>Rollovers</title>
 <section id="key-rollovers">
  <title>Key Rollovers</title>
  <para>Just like passwords and underwear, DNSSEC keys should be changed
  periodically.  This change of keys is known as a "rollover". There are
  arguments for and against rolling keys, which are discussed elsewhere.
  </para>

  <para>Before going any further, it is worth noting that if you sign
  your zone with either the Automatic or Semi-Automatic method, you
  don't really need to concern yourself with the details of a key rollover:
  BIND takes care of it all for ou (apart from key creation if using the
  semi-automatic method).  If you are doing a manual key roll, you do
  need to concern yourself with the various steps involved and the
  timing details.</para>

  <para>Rolling a key is not as simple as replacing the DNSKEY statement
  in the zone.  That is an essential part of it, but timing is everything.
  For example, suppose that we run the <code>example.com</code> zone
  and that someone lookups the AAAA record for <code>www.example.com</code>.
  As part of the resolution process (described in 
  <xref linkend="how-does-dnssec-change-dns-lookup"/>), their recursive server
  looks up the keys for the <code>example.com</code> zone and uses them to
  verify the signature associated with the AAAA record.  We'll assume that
  the records validated successfully, so all is well so they can use the
  address to visit example.com's web site.</para>
  
  <para>Let's assume now that immediately after the lookup, we want to roll the keys
  for <code>example.com</code>.  Our first attempt at this is to remove the old
  DNSKEY records and signatures, add new DNSKEY records, and re-sign the zone.
  So one minute their server is serving the old DNSKEYs and records signed with
  those old keys then the next minute it is serving the new keys and records
  signed with the new keys.  We've achieved out goal - we are serving a zone
  signed with the new keys and to check this is really the case, we booted up our
  laptop and looked up the AAAA record <code>ftp.example.com</code>. The lookup
  succeeded so all must be well.  Or is it?  Just to be sure, we asked
  our friend working in another office to check.
  They tried to lookup <code>ftp.example.com</code> but got a SERVFAIL
  response from their recursive server.  So what's going on?</para>

  <para>The answer, in one word, is "caching".  When they looked up
  <code>www.example.com</code>, as well as retrieving the A record, their
  recursive server
  retrieved and cached a lot of other records.  It cached the NS records for
  <code>com</code> and <code>example.com</code>.  It looked up and cached the
  AAAA (and A) records for those nameservers (this action possibly causing the
  lookup and caching of more NS and AAAA/A records).  Most importantly for this
  example, it also looked up and cached the DNSKEY records for the root,
  <code>com</code> and <code>example.com</code> zones.  When a query was made
  for <code>ftp.example.com</code>, it had already most of the information we
  needed.  It knew what nameservers served <code>example.com</code> and their
  addresses, so we went directly to one of those to get the AAAA record for
  <code>ftp.example.com</code> and its associated signature.  But when it came
  to validate the signature, it used the cached copy of the DNSKEY, and that is
  when our user had the problem.  The recursive server had a copy of the old DNSKEY in
  its cache, but the AAAA record for <code>ftp.example.com</code> was signed
  with the new key.  So not surprisingly, the signature didn't validate.</para>

  <para>So just how should we roll the keys for <code>example.com</code>?
  A clue to the answer is to note that
  the problem came about because the DNSKEY records were cached by
  the recursive server.  What would have happened had out user flushed the DNSKEY
  records from the recursive server's cache before making the query?  That
  would have worked; those records would have to be retrieved from
  <code>example.com</code>'s nameservers at the same time that we
  retrieved the AAAA record for <code>ftp.example.com</code>.  So we
  would have obtained the new key along with the AAAA record and associated
  signature created with the new key.  All would have been well.</para>
  
  <para>As it is obviously impossible for us to notify all recursive server operators
  to flush our DNSKEY records every time we roll a key, we have to use another
  solution.  That solution is to take our time and to wait for the
  recursive servers to remove old records from caches when they reach their
  TTL.  How exactly we do this depends on whether we are trying to roll
  a ZSK, a KSK or a CSK.</para>

  <!-- ====== ZSK Rollover ====== -->
  <section id="zsk-rollover-methods">
   <title>ZSK Rollover Methods</title>
   <para>The ZSK can be rolled in one of the following two ways:
    <orderedlist>
     <!-- #1 Pre-publication -->
     <listitem>
      <simpara><emphasis>Pre-publication</emphasis>: Publish the new ZSK into zone
      data before it is actually used. Wait at least one TTL so the world's
      recursive servers know about both keys, then stop using the old key and
      generate new RRSIG using the new key. Wait at least another TTL, so the
      cached old key data is expunged from world's recursive servers, before
      removing the old key.</simpara>

      <simpara>The benefit of the Pre-publication approach is it does not
      dramatically increase the zone size, but the duration of the rollover is
      longer. If insufficient time has passed after the new ZSK is
      published, some resolvers may only have the old ZSK cached when the new
      RRSIG records are published, and validation may fail. This is the method
      that was described in <xref linkend="maintenance-tasks-zsk-rollover"
      /> and <xref linkend="recipes-zsk-rollover" /></simpara>
     </listitem>

     <!-- #2 Double Signature -->
     <listitem>
      <simpara><emphasis>Double Signature</emphasis>: Publish the new ZSK and new
      RRSIG, essentially double the size of the zone. Wait at least one TTL
      before removing the old ZSK and old RRSIG.</simpara>

      <simpara>The benefit of the Double Signature approach is that it is
      easier to understand and execute, but suffers from increased zone size
      (essentially double) during a rollover event.</simpara>
     </listitem>
    </orderedlist>
   </para>
  </section>

  <!-- ====== KSK Rollover ====== -->
  <section id="ksk-rollover-methods">
   <title>KSK Rollover Methods</title>
   <para>Rolling the KSK requires interaction with the parent zone, so
   operationally this may be more complex than rolling ZSKs. There are three
   methods of rolling the KSK:

    <orderedlist>
     <!-- #1 Double-DS -->
     <listitem>
      <simpara><emphasis>Double-DS</emphasis>: the new DS record is published.
      After waiting for this change to propagate into caches, the KSK is
      changed.  After a further interval during which the old DNSKEY RRset
      expires from caches, the old DS record is removed.</simpara>

      <simpara>Double-DS is the reverse of Double-KSK: the new DS is published
      at the parent first, then the KSK at the child is updated, then remove
      the old DS at the parent. The benefit is that the size of the DNSKEY
      RRset is kept to a minimum, but interactions with the parent zone is
      increased to two events. This is the method that is described in <xref
      linkend="maintenance-tasks-ksk-rollover" /> and <xref
      linkend="recipes-ksk-rollover" />. </simpara>
     </listitem>

     <!-- #2 Double-KSK -->
     <listitem>
      <simpara><emphasis>Double-KSK</emphasis>: the new KSK is added to the
      DNSKEY RRset which is then signed with both the old and new key.  After
      waiting for the old RRset to expire from caches, the DS record in the
      parent zone is changed.  After waiting a further interval for this change
      to be reflected in caches, the old key is removed from the
      RRset.</simpara>

      <simpara>Basically, the new KSK is added first at the child zone and
      being used to sign DNSKEY, then the DS record is changed, followed by the
      removal of the old KSK. Double-KSK limits the interaction with the parent
      zone to a minim, but for the duration of the rollover, the size of the
      DNSKEY RRset is increased.</simpara>
     </listitem>
  
     <!-- #3 Double-RRset -->
     <listitem>
      <simpara><emphasis>Double-RRset</emphasis>: the new KSK is added to the
      DNSKEY RRset which is then signed with both the old and new key, and the
      new DS record added to the parent zone.  After waiting a suitable
      interval for the old DS and DNSKEY RRsets to expire from caches, the old
      DNSKEY and DS record are removed.</simpara>

      <simpara>Double-RRset is the fastest way to roll the KSK (shortest
      rollover time), but has the drawbacks of both of the other methods: a
      larger DNSKEY RRset and two interactions with the parent.</simpara>
     </listitem>
    </orderedlist>
   </para>
  </section>

  <!-- ====== CSK Rollover ====== -->
  <section id="csk-rollover-methods">
   <title>CSK Rollover Methods</title>
   <para>Rolling the CSK is more complex than rolling either the ZSK or
   KSK, as the timing constraints relating to both the parent zone and
   the caching of records by downstream recursive servers have to be
   taken into account.  There is essentially one method:

    <orderedlist>
     <!-- #1 Double-DNSKEY -->
     <listitem>
      <simpara><emphasis>Double-DS</emphasis>: the new CSK is added to
      the DNSKEY RRset and the new DS record is assed to the parent zone's
      DS RRset.  Once the old DS and DNSKEY RRsets have expired from caches,
      the zone is signed with the new key.  After waiting a further amount of
      time for records signed with the old key to expire from caches,
      the old CSK and DS records are withdrawn from their respective
      RRsets.</simpara>
     </listitem>
    </orderedlist>
   </para>
   
  </section>
 </section>
</section>
